### 切片不包含结束位置
对于`newSlice = Slice[起始位置:结束位置]`，newSlice中不包含结束位置。
比如在将切片一分为二时是`slice[0:pos]`和`slice[pos:]`前一个不包含后一个包含`pos`
而删除一个元素则是`append(slice[0:pos]`,`slice[pos+1:])`，前一个不包含`pos`，因此删除的就是`pos`所指的那个元素。

### printf中的++v
`%+v` 先输出字段名字，在输出字段的值
`%++v` use "`%##v`" "`%++v`" to format a value with indented-multi-lines style string to extends "%#v" "%+v".
输出多行缩进样式的字符串来扩展`%+v`
```
func ExamplePrintf_flagV() {
	type X struct {
		A int
		B string
	}
	type Y struct {
		D X
		E []int
		F [2]string
	}
	type Z struct {
		G Y
		H string
		I []string
		J map[string]int
	}
	var z = Z{
		G: Y{
			D: X{
				A: 123,
				B: `"b" = 1`,
			},
			E: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
			F: [2]string{
				`aaa`,
				`bbb`,
			},
		},
		H: `zzz`,
		I: []string{
			`c:\x\y\z`,
			`d:\a\b\c`,
		},
		J: map[string]int{
			`abc`: 456,
		},
	}
	fmt.Printf("-------\n\"%%v\":\n%v\n", z)
	fmt.Printf("-------\n\"%%#v\":\n%#v\n", z)
	fmt.Printf("-------\n\"%%##\"v:\n%##v\n", z)
	fmt.Printf("-------\n\"%%+v\":\n%+v\n", z)
	fmt.Printf("-------\n\"%%++v\":\n%++v\n", z)

	// Output:
	// -------
	// "%v":
	// {{{123 "b" = 1} [1 2 3 4 5 6 7 8 9 10 11 12] [aaa bbb]} zzz [c:\x\y\z d:\a\b\c] map[abc:456]}
	// -------
	// "%#v":
	// fmt_test.Z{G:fmt_test.Y{D:fmt_test.X{A:123, B:"\"b\" = 1"}, E:[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, F:[2]string{"aaa", "bbb"}}, H:"zzz", I:[]string{"c:\\x\\y\\z", "d:\\a\\b\\c"}, J:map[string]int{"abc":456}}
	// -------
	// "%##"v:
	// fmt_test.Z{
	//     G: fmt_test.Y{
	//         D: fmt_test.X{
	//             A: 123,
	//             B: `"b" = 1`,
	//         },
	//         E: []int{
	//             1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	//             11, 12,
	//         },
	//         F: [2]string{
	//             `aaa`,
	//             `bbb`,
	//         },
	//     },
	//     H: `zzz`,
	//     I: []string{
	//         `c:\x\y\z`,
	//         `d:\a\b\c`,
	//     },
	//     J: map[string]int{
	//         `abc`: 456,
	//     },
	// }
	// -------
	// "%+v":
	// {G:{D:{A:123 B:"b" = 1} E:[1 2 3 4 5 6 7 8 9 10 11 12] F:[aaa bbb]} H:zzz I:[c:\x\y\z d:\a\b\c] J:map[abc:456]}
	// -------
	// "%++v":
	// {
	//     G: {
	//         D: {
	//             A: 123
	//             B: "b" = 1
	//         }
	//         E: [
	//             1 2 3 4 5 6 7 8 9 10
	//             11 12
	//         ]
	//         F: [
	//             aaa
	//             bbb
	//         ]
	//     }
	//     H: zzz
	//     I: [
	//         c:\x\y\z
	//         d:\a\b\c
	//     ]
	//     J: map[
	//         abc: 456
	//     ]
	// }
}
```

### 切片的初始化
`mySlice1 := make([]int, 0)` 、`mySlice2 := []int{}`这两种切片的初始化那种是正确的？两种都可以，**本质上是相同的**。
[参考](https://stackoverflow.com/questions/29164375/correct-way-to-initialize-empty-slice)

### 处理panic
当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用`panic()`函数产生一个中止程序的运行时错误。
标准库中有许多包含`Must`前缀的函数，像`regexp.MustComplie()`和`template.Must()`，这表明当正则表达式或模板中传入的转换字符串导致错误时，这些函数会`panic()`
不能随意地用`panic()`中止程序，必须尽力补救错误让程序能继续执行。
#### panic转换为错误

1. 在包内部，总是应该从 `panic` 中 `recover`：不允许显式的超出包范围的`panic()`
2. 向包的调用者返回错误值（而不是 `panic`）

在包内部，特别是在非导出函数中有很深层次的嵌套调用时，将 `panic` 转换成 `error` 来告诉调用方为何出错，是很实用的（且提高了代码可读性）。
#### panic正确处理方式
`defer`是在`return`执行之后，以及调用者获取数据之前执行。因此使用`defer`处理`panic`将其转换为`error`，应该是修改`error`的内容。
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
	defer func() {
		if rerr := recover(); rerr != nil {
			err = common.ErrInterrupted
		}
	}()
}
```
下面这种返回的方式是错误的
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
    defer func() error {
		if err := recover(); err != nil {
			log.Errorf("mongo read panic recover error:%v", err)
			return common.ErrInterrupted
        }
    }()
}
```
还要注意的一点是，要修改返回值，需要先声明参数，也就是`err error`部分。如果没有声明返回值，修改是无效的。

### Mutex和RWMutex
- `Mutex`：互斥锁Mutex类型有两个方法，Lock和Unlock
- `RWMutex`：读写互斥锁RWMutex有五个方法，Lock\Unlock\Rlock\RUnlock\RLocker.RLocker为读操作返回一个Locker接口的对象。它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法。
`区别`：对于mutex在任何情况下加锁，其他部分访问都会阻塞。而对于rwmutex，在读锁处于锁定状态后，再加锁不会导致阻塞，也就是读锁支持共享读。

### close+channel同时启动多个协程
首先构造一个无缓冲的`channel`
```go
ready := make(chan struct{})
```
然后使用`<-ready`阻塞某一段代码，最后在需要启动的时候使用`close（ready)`，这样所有`<-ready`被阻塞的`channel`就会非阻塞，来运行后续代码。
#### 等待完成
```go
done := make(chan struct{})
go func() {
  doA()
  close(done)
}()
// 等待A完成
<-done
```
#### 同时启动
```go
start := make(chan struct{})
for i := 0; i < 10000; i++ {
  go func() {
    <-start // wait for the start channel to be closed
    doWork(i) // do something
 }()
}
//这时候所有阻塞的协程都可以继续运行
close(start)
```
#### 暂停循环
```go
loop:
for {
  select {
  case m := <-email:
    sendEmail(m)
  case <-stop: // triggered when the stop channel is closed
    break loop // exit
  }
}
```

### golang中的Enable Go modules integration在做什么
`goland`有两种方式获得包信息。
- `GOPATH` IDEA 扫描您的`$GOPATH`目录以构建包的内部索引并提供代码完成、解析等。
- `Go modules` IDEA执行`go list -m -json`来解决您的依赖关系并扫描您的 `$GOPATH/pkg/mod` 目录（GOMODCACHE 的默认值）以查找包。如果它们不存在，IDEA 会执行 `go mod download`。在这些操作之后，IDE 提供了所有内置功能，如代码补全等。
这两种模式都不会改变您的 Go 或环境变量以及终端中的行为。 当您在设置中选中 `Enable Go Modules integration` 选项时，IDE 只需将模式从扫描`$GOPATH`切换到执行 `go list` 并从 `Go Modules` 缓存中解析您的依赖项。

### goroutine中使用log.Fatal
在`goroutine`中使用`log.Fatal`，由于其调用`os.Exit`，会使得整个进程退出。
```go
func Test_logFatal(t *testing.T) {
	go func() {
		log.Fatal("A")
	}()
	time.Sleep(2 * time.Second)
	t.Log("a")
}
```

### go vendor 
我们的目的是使用`go mod vendor`，将项目的依赖库下载到项目内部（可以在没有网络的情况下进行编译），即项目中包含依赖库源码，依赖库如同项目的一部分，也收到项目的版本管控。

### 空结构体
空结构体`struct{}`不占存储空间，它有如下用途
> _The size of a struct is the sum of the size of the types of its fields, since there are no fields: no size!_

#### Free Map
构造一个值为空结构题的map，用于校验`key`是否存在。
```go
myMap map[string]struct{}
if ok := myMap["key"];ok{
	//dosomething
}
```
#### Semaphores and tokens
将空结构体作为信号量处理
```go
sem := make(chan struct{},10)
//生产
sem <- struct{}{}
//消费
<- sem

```

### append删除切片元素
append(a[:i],a[i+1:])即可将i~1-n的部分追加到0~i的部分，这样就删除了原来第i+1位置的元素

### omitempty+指针字段
我们可以在 `Golang` 的结构体定义中添加 `omitempty` 关键字，来表示这条信息如果没有提供，在序列化成 `json` 的时候就不要包含其默认值。即如下这个`street`字段如果为空
```go
data := {
    "street": "",
}
```
下面这种方式解析的结果，json中包含`street`字段。
```go
type address struct {
	Street  string `json:"street"`  // 街道
}
```
```json
{
	"street": "",
}
```
而如果填写了`omitempty`，空字段情况下`json`就不包含该字段。
```go
type address struct {
	Street  string `json:"street,omitempty"`  // 街道
}
```
#### 指针字段与omitempty
> Using a pointer field, and specify omitempty allows you to do that. If the field wasn't specified in the JSON data, then the field in your struct will be nil, if not: it'll point to an integer of value 0.

指针字段+`omitempty`的好处是，`json`解码后，如果`json`不包含该字段则指针字段为`nil`，否则`json`中字段存在且值为空，那么指针字段为`0`。

### 交叉编译
在`mac`平台编译`linux`的可执行程序 `CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build ./`
`CGO_ENABLED`：用来控制golang 编译期间是否支持调用 cgo 命令的开关，其值为1或0，默认情况下值为1，可以用 go env 查看默认值。交叉编译不支持 CGO 所以要禁用它
`GOOS`：目标平台的操作系统（darwin、freebsd、linux、windows）
`GOARCH`：目标平台的体系架构（386、amd64、arm）

### import 点、下划线、别名
点操作：`import( . “fmt” )` 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的`fmt.Println(“hello world”)`  可以省略的写成`Println(“hello world”)`
别名操作：`import( f “fmt” )`别名操作调用包函数时前缀变成了重命名的前缀，即`f.Println(“hello world”)`
下划线操作：忽略包

### time.Now().After()与time.After()
`time.Now().After()`是属于`time/time`，一般主动调用`after`来通过返回的`bool`了解是否在时刻`u`之后。
```go
// After reports whether the time instant t is after u.
func (t Time) After(u Time) bool {
	if t.wall&u.wall&hasMonotonic != 0 {
		return t.ext > u.ext
	}
	ts := t.sec()
	us := u.sec()
	return ts > us || ts == us && t.nsec() > u.nsec()
}
```
`time.After()`属于`time/sleep`。是对`NewTimer()`的封装，返回一个channel
```go
// After waits for the duration to elapse and then sends the current time
// on the returned channel.
// It is equivalent to NewTimer(d).C.
// The underlying Timer is not recovered by the garbage collector
// until the timer fires. If efficiency is a concern, use NewTimer
// instead and call Timer.Stop if the timer is no longer needed.
func After(d Duration) <-chan Time {
	return NewTimer(d).C
}
```
通常是定时后，配合`select`使用如下例子。`select`会执行表达式`time.After`，并试着读取，由于还没有到after，即阻塞。此时有其他`case`触发也可以执行。在计时器计时结束后，`case <-time.After(timeout):`会被触发。
```go
select{
    case <-time.After(timeout):
    case xx:
}
```

### 中文字符处理
golang中一个汉字占3个字节，如果按照字节输出，会造成乱码。又因为string的底层实现是`[]byte`，因此访问字符串`str[i]`是访问某个字节，所以如果字符串是中文打印出来就会乱码。
这时候需要范围更大能够表示三个字节内容的实现，即`rune[]`每个单位占4字节。如`runeArr:=[]rune("你好")`即可正常输出。

### 控制goroutine数量
可以通过`channel`控制协程数量，首先初始化定义好`channel`缓冲区大小。
```go
func NewRunner() (*CountRunner, error) {
	return &CountRunner{
		InputQ:             make(chan *Task, 10),
		CompleteQ:          make(chan *Task, 10),
		ConcurrencyControl: make(chan struct{}, 10),
	}, nil
}
```
然后在`Run()`中，每一次取任务则到`ConcurrencyControl`做标记，每次任务完成，则消耗`ConcurrencyControl`中一个标记，这样如果有一定数量的任务未完成，则`ConcurrencyControl`添加标记会卡住，导致无法使用新的`goroutine`消费任务。
```go
func (th *Runner) Run() {
	for {
		th.ConcurrencyControl <- struct{}{}
		task := <-th.InputQ
		go func() {
			th.CompleteQ <- th.run(task)
			<-th.ConcurrencyControl
		}()
	}
}
```
[参考](https://geektutu.com/post/hpg-concurrency-control.html)

### 切片扩张导致不同的空间引用
如下面的例子，`s1`、`s2`最开始引用同一片空间，但如果`s1`\`s2`中某一个切片的`append`导致内存分配即`cap`变大，则`s1`、`s2`原来指向同一片空间然后会变成分别指向两片区域，分别是扩张的区域和未扩张的区域，
```go
package main

func main() {
    //初始化两个slice
    s1 := make([]int, 3, 4)
    s2 := s1[: 2]

    s2[0] ++
    println(s1[0] == s2[0]) //true

    s1 = append(s1, 0)
    s2[0] ++
    println(s1[0] == s2[0]) //true

    s1 = append(s1, 0)
    s2[0] ++
    println(s1[0] == s2[0]) //false
}
```

### golang实现闭包
`wiki`中闭包的实现描述如下
> 闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。下面的例子中，`getSequence`返回一个闭包，它提供了函数入口并且自己维护相关变量`i`。可以通过`nextNumber := getSequence()`，`nextNumber()`使用闭包。
```go
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
     return i  
   }
}

func main(){
   /* nextNumber 为一个函数，函数 i 为 0 */
   nextNumber := getSequence()  

   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   
   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())
   fmt.Println(nextNumber1())
}
```

### 并发append
`append`操作是并发不安全的，这是因为`slice`维护`ptr`、`cap`、`len`三个值，其中并发情况下，`ptr`指向的一块区域被写入不同的值，这样就造成`slice`的长度不符合预期。`go test -v -race -run TestSlice`运行下面测试可以看到错误。
```go
package main

import (
    "sync"
    "testing"
)

func TestSlice(t *testing.T) {
    s := []int{}
    var wg sync.WaitGroup

    // 外部变量记录每个 goroutine append 的数量
    count := 0
    // 10 个 goroutine 并发 append 10000 个数字到 slice s 中，最终 s 正确长度为 10 * 10000 = 100000
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i, count int) {
            for j := 0; j < 10000; j++ {
                s = append(s, j)
                count++
            }
            t.Logf("G%d append count:%d\n", i, count)
            wg.Done()
        }(i, count)
    }
    wg.Wait()

    if len(s) != 100000 {
        t.Errorf("s.len:%d != 100000", len(s))
    }
}
```
解决办法是加锁。
```go
mu.Lock()
s = append(s, j)
mu.Unlock()
```
### 闭包使用外部变量
闭包可以直接使用外部变量或者作为参数传入使用，下面这种情况应该注意。
闭包+循环的使用，下面这种写法无法达到效果。这是因为`val`传递的是地址，加上并发的异步性，很可能在循环之后才执行`println`，这时地址指向的是`values`的结尾。
```go
for _, val := range values {
    go func() {
        fmt.Println(val)
    }()
}

```
创建变量
```go
for i := range valslice {
    val := valslice[i]
    go func() {
        fmt.Println(val)
    }()
}
```
传入参数
```go
for _, val := range values {
    go func(val interface{}) {
        fmt.Println(val)
    }(val)
}
```
以上两种写法都可以解决问题。

### delete的key在map中不存在
```go
package main
 
import "fmt"
 
func main() {
	demo := make(map[string]interface{})
	delete(demo, "author")
	fmt.Println(demo)
	// outputs: map[]
}

```

### defer在{}中
由于defer是在函数return之后，才会出栈执行，因此在{}中defer是不受影响的。
```go
func TestA(t *testing.T) {
	log.Println("begin")
	if true {
		defer func() {
			log.Println("end")
		}()
		log.Println("in if")
	}
	log.Println("out if")
}
```

### int类型是多少
通过下面代码的运行结果可以看到，int和int64的运行结果是一样的。
```go
package main

import (
        "fmt"
        "unsafe"
)

func main() {
        var i1 int = 1
        var i2 int8 = 2
        var i3 int16 = 3
        var i4 int32 = 4
        var i5 int64 = 5
        fmt.Println(unsafe.Sizeof(i1))
        fmt.Println(unsafe.Sizeof(i2))
        fmt.Println(unsafe.Sizeof(i3))
        fmt.Println(unsafe.Sizeof(i4))
        fmt.Println(unsafe.Sizeof(i5))
}
// unsafe.Sizeof()  只返回数据类型的大小，不管引用数据的大小,单位为Byte
```
官方文档对于int的解释是*int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32.*，也就是int最少32位，但它并不是int32的别名。
最后的结论就是：int大小和操作系统有关，如果操作系统是32位，int对应4字节。操作系统是64位，则int对应8字节。