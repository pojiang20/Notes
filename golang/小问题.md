### 切片不包含结束位置
对于`newSlice = Slice[起始位置:结束位置]`，newSlice中不包含结束位置。
比如在将切片一分为二时是`slice[0:pos]`和`slice[pos:]`前一个不包含后一个包含`pos`
而删除一个元素则是`append(slice[0:pos]`,`slice[pos+1:])`，前一个不包含`pos`，因此删除的就是`pos`所指的那个元素。

### printf中的++v
`%+v` 先输出字段名字，在输出字段的值
`%++v` use "`%##v`" "`%++v`" to format a value with indented-multi-lines style string to extends "%#v" "%+v".
输出多行缩进样式的字符串来扩展`%+v`
```
func ExamplePrintf_flagV() {
	type X struct {
		A int
		B string
	}
	type Y struct {
		D X
		E []int
		F [2]string
	}
	type Z struct {
		G Y
		H string
		I []string
		J map[string]int
	}
	var z = Z{
		G: Y{
			D: X{
				A: 123,
				B: `"b" = 1`,
			},
			E: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
			F: [2]string{
				`aaa`,
				`bbb`,
			},
		},
		H: `zzz`,
		I: []string{
			`c:\x\y\z`,
			`d:\a\b\c`,
		},
		J: map[string]int{
			`abc`: 456,
		},
	}
	fmt.Printf("-------\n\"%%v\":\n%v\n", z)
	fmt.Printf("-------\n\"%%#v\":\n%#v\n", z)
	fmt.Printf("-------\n\"%%##\"v:\n%##v\n", z)
	fmt.Printf("-------\n\"%%+v\":\n%+v\n", z)
	fmt.Printf("-------\n\"%%++v\":\n%++v\n", z)

	// Output:
	// -------
	// "%v":
	// {{{123 "b" = 1} [1 2 3 4 5 6 7 8 9 10 11 12] [aaa bbb]} zzz [c:\x\y\z d:\a\b\c] map[abc:456]}
	// -------
	// "%#v":
	// fmt_test.Z{G:fmt_test.Y{D:fmt_test.X{A:123, B:"\"b\" = 1"}, E:[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, F:[2]string{"aaa", "bbb"}}, H:"zzz", I:[]string{"c:\\x\\y\\z", "d:\\a\\b\\c"}, J:map[string]int{"abc":456}}
	// -------
	// "%##"v:
	// fmt_test.Z{
	//     G: fmt_test.Y{
	//         D: fmt_test.X{
	//             A: 123,
	//             B: `"b" = 1`,
	//         },
	//         E: []int{
	//             1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	//             11, 12,
	//         },
	//         F: [2]string{
	//             `aaa`,
	//             `bbb`,
	//         },
	//     },
	//     H: `zzz`,
	//     I: []string{
	//         `c:\x\y\z`,
	//         `d:\a\b\c`,
	//     },
	//     J: map[string]int{
	//         `abc`: 456,
	//     },
	// }
	// -------
	// "%+v":
	// {G:{D:{A:123 B:"b" = 1} E:[1 2 3 4 5 6 7 8 9 10 11 12] F:[aaa bbb]} H:zzz I:[c:\x\y\z d:\a\b\c] J:map[abc:456]}
	// -------
	// "%++v":
	// {
	//     G: {
	//         D: {
	//             A: 123
	//             B: "b" = 1
	//         }
	//         E: [
	//             1 2 3 4 5 6 7 8 9 10
	//             11 12
	//         ]
	//         F: [
	//             aaa
	//             bbb
	//         ]
	//     }
	//     H: zzz
	//     I: [
	//         c:\x\y\z
	//         d:\a\b\c
	//     ]
	//     J: map[
	//         abc: 456
	//     ]
	// }
}
```

### 切片的初始化
`mySlice1 := make([]int, 0)` 、`mySlice2 := []int{}`这两种切片的初始化那种是正确的？两种都可以，**本质上是相同的**。
[参考](https://stackoverflow.com/questions/29164375/correct-way-to-initialize-empty-slice)

### 处理panic
当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用`panic()`函数产生一个中止程序的运行时错误。
标准库中有许多包含`Must`前缀的函数，像`regexp.MustComplie()`和`template.Must()`，这表明当正则表达式或模板中传入的转换字符串导致错误时，这些函数会`panic()`
不能随意地用`panic()`中止程序，必须尽力补救错误让程序能继续执行。
#### panic转换为错误

1. 在包内部，总是应该从 `panic` 中 `recover`：不允许显式的超出包范围的`panic()`
2. 向包的调用者返回错误值（而不是 `panic`）

在包内部，特别是在非导出函数中有很深层次的嵌套调用时，将 `panic` 转换成 `error` 来告诉调用方为何出错，是很实用的（且提高了代码可读性）。
#### panic正确处理方式
`defer`是在`return`执行之后，以及调用者获取数据之前执行。因此使用`defer`处理`panic`将其转换为`error`，应该是修改`error`的内容。
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
	defer func() {
		if rerr := recover(); rerr != nil {
			err = common.ErrInterrupted
		}
	}()
}
```
下面这种返回的方式是错误的
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
    defer func() error {
		if err := recover(); err != nil {
			log.Errorf("mongo read panic recover error:%v", err)
			return common.ErrInterrupted
        }
    }()
}
```
还要注意的一点是，要修改返回值，需要先声明参数，也就是`err error`部分。如果没有声明返回值，修改是无效的。

### Mutex和RWMutex
- `Mutex`：互斥锁Mutex类型有两个方法，Lock和Unlock
- `RWMutex`：读写互斥锁RWMutex有五个方法，Lock\Unlock\Rlock\RUnlock\RLocker.RLocker为读操作返回一个Locker接口的对象。它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法。
`区别`：对于mutex在任何情况下加锁，其他部分访问都会阻塞。而对于rwmutex，在读锁处于锁定状态后，再加锁不会导致阻塞，也就是读锁支持共享读。

### close+channel同时启动多个协程
首先构造一个无缓冲的`channel`
```go
ready := make(chan struct{})
```
然后使用`<-ready`阻塞某一段代码，最后在需要启动的时候使用`close（ready)`，这样所有`<-ready`被阻塞的`channel`就会非阻塞，来运行后续代码。
#### 等待完成
```go
done := make(chan struct{})
go func() {
  doA()
  close(done)
}()
// 等待A完成
<-done
```
#### 同时启动
```go
start := make(chan struct{})
for i := 0; i < 10000; i++ {
  go func() {
    <-start // wait for the start channel to be closed
    doWork(i) // do something
 }()
}
//这时候所有阻塞的协程都可以继续运行
close(start)
```
#### 暂停循环
```go
loop:
for {
  select {
  case m := <-email:
    sendEmail(m)
  case <-stop: // triggered when the stop channel is closed
    break loop // exit
  }
}
```

### golang中的Enable Go modules integration在做什么
`goland`有两种方式获得包信息。
- `GOPATH` IDEA 扫描您的`$GOPATH`目录以构建包的内部索引并提供代码完成、解析等。
- `Go modules` IDEA执行`go list -m -json`来解决您的依赖关系并扫描您的 `$GOPATH/pkg/mod` 目录（GOMODCACHE 的默认值）以查找包。如果它们不存在，IDEA 会执行 `go mod download`。在这些操作之后，IDE 提供了所有内置功能，如代码补全等。
这两种模式都不会改变您的 Go 或环境变量以及终端中的行为。 当您在设置中选中 `Enable Go Modules integration` 选项时，IDE 只需将模式从扫描`$GOPATH`切换到执行 `go list` 并从 `Go Modules` 缓存中解析您的依赖项。

### goroutine中使用log.Fatal
在`goroutine`中使用`log.Fatal`，由于其调用`os.Exit`，会使得整个进程退出。
```go
func Test_logFatal(t *testing.T) {
	go func() {
		log.Fatal("A")
	}()
	time.Sleep(2 * time.Second)
	t.Log("a")
}
```
### 值返回还是指针返回
返回值还是指针，影响的是内存分配问题。
#### 逃逸分析
`Go`的垃圾回收机制是自动管理的，`Go`编译器决定内存分配位置的方式，即判断变量需要分配在栈上还是堆上，这种行为称作逃逸分析。
逃逸分析由编译器完成，作用域编译阶段。
#### 指针逃逸
函数中创建了一个对象，返回该对象的指针。这种情况导致函数虽然退出了，但由于指针的存在对象的内存不能随着函数结束而回收，因此只能分配在堆上。
```go
// main_pointer.go
package main

import "fmt"

type Demo struct {
	name string
}

func createDemo(name string) *Demo {
	d := new(Demo) // 局部变量 d 逃逸到堆
	d.name = name
	return d
}

func main() {
	demo := createDemo("demo")
	fmt.Println(demo)
}
```
即这种情况造成逃逸到堆上了。
#### interface{}动态类型逃逸
由于`interface{}`空接口可以表示任意的类型，如果参数为`interface{}`，编译期间很难确定其参数的具体类型，也会发生逃逸。如下面`Println`的interface{}参数
```go
func main() {
	demo := createDemo("demo")
	fmt.Println(demo)
}
```
demo 是 main 函数中的一个局部变量，该变量作为实参传递给 fmt.Println()，但是因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。
#### 栈空间不足
对于 Go 语言来说，运行时(runtime) 尝试在 goroutine 需要的时候动态地分配栈空间，goroutine 的初始栈大小为 2 KB。当 goroutine 被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统的限制。
对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。
#### 使用闭包
> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。
> — [闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

```go
func Increase() func() int {
	n := 0
	return func() int {
		n++
		return n
	}
}

func main() {
	in := Increase()
	fmt.Println(in()) // 1
	fmt.Println(in()) // 2
}
```
Increase() 返回值是一个闭包函数，该闭包函数访问了外部变量 n，那变量 n 将会一直存在，直到 in 被销毁。很显然，变量 n 占用的内存不能随着函数 Increase() 的退出而回收，因此将会逃逸到堆上。
#### 传值 vs 传指针
传指针的好处是可以减少值的拷贝以及方便判断，但会导致内存分配逃逸到堆中，增加`GC`的负担。
一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。
[参考1](https://segmentfault.com/q/1010000019133280)[参考2](https://geektutu.com/post/hpg-escape-analysis.html)