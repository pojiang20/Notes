### 切片不包含结束位置
对于`newSlice = Slice[起始位置:结束位置]`，newSlice中不包含结束位置。
比如在将切片一分为二时是`slice[0:pos]`和`slice[pos:]`前一个不包含后一个包含`pos`
而删除一个元素则是`append(slice[0:pos]`,`slice[pos+1:])`，前一个不包含`pos`，因此删除的就是`pos`所指的那个元素。

### printf中的++v
`%+v` 先输出字段名字，在输出字段的值
`%++v` use "`%##v`" "`%++v`" to format a value with indented-multi-lines style string to extends "%#v" "%+v".
输出多行缩进样式的字符串来扩展`%+v`
```
func ExamplePrintf_flagV() {
	type X struct {
		A int
		B string
	}
	type Y struct {
		D X
		E []int
		F [2]string
	}
	type Z struct {
		G Y
		H string
		I []string
		J map[string]int
	}
	var z = Z{
		G: Y{
			D: X{
				A: 123,
				B: `"b" = 1`,
			},
			E: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},
			F: [2]string{
				`aaa`,
				`bbb`,
			},
		},
		H: `zzz`,
		I: []string{
			`c:\x\y\z`,
			`d:\a\b\c`,
		},
		J: map[string]int{
			`abc`: 456,
		},
	}
	fmt.Printf("-------\n\"%%v\":\n%v\n", z)
	fmt.Printf("-------\n\"%%#v\":\n%#v\n", z)
	fmt.Printf("-------\n\"%%##\"v:\n%##v\n", z)
	fmt.Printf("-------\n\"%%+v\":\n%+v\n", z)
	fmt.Printf("-------\n\"%%++v\":\n%++v\n", z)

	// Output:
	// -------
	// "%v":
	// {{{123 "b" = 1} [1 2 3 4 5 6 7 8 9 10 11 12] [aaa bbb]} zzz [c:\x\y\z d:\a\b\c] map[abc:456]}
	// -------
	// "%#v":
	// fmt_test.Z{G:fmt_test.Y{D:fmt_test.X{A:123, B:"\"b\" = 1"}, E:[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, F:[2]string{"aaa", "bbb"}}, H:"zzz", I:[]string{"c:\\x\\y\\z", "d:\\a\\b\\c"}, J:map[string]int{"abc":456}}
	// -------
	// "%##"v:
	// fmt_test.Z{
	//     G: fmt_test.Y{
	//         D: fmt_test.X{
	//             A: 123,
	//             B: `"b" = 1`,
	//         },
	//         E: []int{
	//             1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	//             11, 12,
	//         },
	//         F: [2]string{
	//             `aaa`,
	//             `bbb`,
	//         },
	//     },
	//     H: `zzz`,
	//     I: []string{
	//         `c:\x\y\z`,
	//         `d:\a\b\c`,
	//     },
	//     J: map[string]int{
	//         `abc`: 456,
	//     },
	// }
	// -------
	// "%+v":
	// {G:{D:{A:123 B:"b" = 1} E:[1 2 3 4 5 6 7 8 9 10 11 12] F:[aaa bbb]} H:zzz I:[c:\x\y\z d:\a\b\c] J:map[abc:456]}
	// -------
	// "%++v":
	// {
	//     G: {
	//         D: {
	//             A: 123
	//             B: "b" = 1
	//         }
	//         E: [
	//             1 2 3 4 5 6 7 8 9 10
	//             11 12
	//         ]
	//         F: [
	//             aaa
	//             bbb
	//         ]
	//     }
	//     H: zzz
	//     I: [
	//         c:\x\y\z
	//         d:\a\b\c
	//     ]
	//     J: map[
	//         abc: 456
	//     ]
	// }
}
```

### 切片的初始化
`mySlice1 := make([]int, 0)` 、`mySlice2 := []int{}`这两种切片的初始化那种是正确的？两种都可以，**本质上是相同的**。
[参考](https://stackoverflow.com/questions/29164375/correct-way-to-initialize-empty-slice)

### 处理panic
当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用`panic()`函数产生一个中止程序的运行时错误。
标准库中有许多包含`Must`前缀的函数，像`regexp.MustComplie()`和`template.Must()`，这表明当正则表达式或模板中传入的转换字符串导致错误时，这些函数会`panic()`
不能随意地用`panic()`中止程序，必须尽力补救错误让程序能继续执行。
#### panic转换为错误

1. 在包内部，总是应该从 `panic` 中 `recover`：不允许显式的超出包范围的`panic()`
2. 向包的调用者返回错误值（而不是 `panic`）

在包内部，特别是在非导出函数中有很深层次的嵌套调用时，将 `panic` 转换成 `error` 来告诉调用方为何出错，是很实用的（且提高了代码可读性）。
#### panic正确处理方式
`defer`是在`return`执行之后，以及调用者获取数据之前执行。因此使用`defer`处理`panic`将其转换为`error`，应该是修改`error`的内容。
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
	defer func() {
		if rerr := recover(); rerr != nil {
			err = common.ErrInterrupted
		}
	}()
}
```
下面这种返回的方式是错误的
```go
func (m *MongoReader) ReadMap(data *map[string]interface{}) (err error) {
    defer func() error {
		if err := recover(); err != nil {
			log.Errorf("mongo read panic recover error:%v", err)
			return common.ErrInterrupted
        }
    }()
}
```
还要注意的一点是，要修改返回值，需要先声明参数，也就是`err error`部分。如果没有声明返回值，修改是无效的。

### Mutex和RWMutex
- `Mutex`：互斥锁Mutex类型有两个方法，Lock和Unlock
- `RWMutex`：读写互斥锁RWMutex有五个方法，Lock\Unlock\Rlock\RUnlock\RLocker.RLocker为读操作返回一个Locker接口的对象。它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法。
`区别`：对于mutex在任何情况下加锁，其他部分访问都会阻塞。而对于rwmutex，在读锁处于锁定状态后，再加锁不会导致阻塞，也就是读锁支持共享读。

### close+channel同时启动多个协程
首先构造一个无缓冲的`channel`
```go
ready := make(chan struct{})
```
然后使用`<-ready`阻塞某一段代码，最后在需要启动的时候使用`close（ready)`，这样所有`<-ready`被阻塞的`channel`就会非阻塞，来运行后续代码。
#### 等待完成
```go
done := make(chan struct{})
go func() {
  doA()
  close(done)
}()
// 等待A完成
<-done
```
#### 同时启动
```go
start := make(chan struct{})
for i := 0; i < 10000; i++ {
  go func() {
    <-start // wait for the start channel to be closed
    doWork(i) // do something
 }()
}
//这时候所有阻塞的协程都可以继续运行
close(start)
```
#### 暂停循环
```go
loop:
for {
  select {
  case m := <-email:
    sendEmail(m)
  case <-stop: // triggered when the stop channel is closed
    break loop // exit
  }
}
```

### golang中的Enable Go modules integration在做什么
`goland`有两种方式获得包信息。
- `GOPATH` IDEA 扫描您的`$GOPATH`目录以构建包的内部索引并提供代码完成、解析等。
- `Go modules` IDEA执行`go list -m -json`来解决您的依赖关系并扫描您的 `$GOPATH/pkg/mod` 目录（GOMODCACHE 的默认值）以查找包。如果它们不存在，IDEA 会执行 `go mod download`。在这些操作之后，IDE 提供了所有内置功能，如代码补全等。
这两种模式都不会改变您的 Go 或环境变量以及终端中的行为。 当您在设置中选中 `Enable Go Modules integration` 选项时，IDE 只需将模式从扫描`$GOPATH`切换到执行 `go list` 并从 `Go Modules` 缓存中解析您的依赖项。

### goroutine中使用log.Fatal
在`goroutine`中使用`log.Fatal`，由于其调用`os.Exit`，会使得整个进程退出。
```go
func Test_logFatal(t *testing.T) {
	go func() {
		log.Fatal("A")
	}()
	time.Sleep(2 * time.Second)
	t.Log("a")
}
```

### go vendor 
我们的目的是使用`go mod vendor`，将项目的依赖库下载到项目内部（可以在没有网络的情况下进行编译），即项目中包含依赖库源码，依赖库如同项目的一部分，也收到项目的版本管控。

### 空结构体
空结构体`struct{}`不占存储空间，它有如下用途
> _The size of a struct is the sum of the size of the types of its fields, since there are no fields: no size!_

#### Free Map
构造一个值为空结构题的map，用于校验`key`是否存在。
```go
myMap map[string]struct{}
if ok := myMap["key"];ok{
	//dosomething
}
```
#### Semaphores and tokens
将空结构体作为信号量处理
```go
sem := make(chan struct{},10)
//生产
sem <- struct{}{}
//消费
<- sem

```

### append删除切片元素
append(a[:i],a[i+1:])即可将i~1-n的部分追加到0~i的部分，这样就删除了原来第i+1位置的元素

### omitempty+指针字段
我们可以在 `Golang` 的结构体定义中添加 `omitempty` 关键字，来表示这条信息如果没有提供，在序列化成 `json` 的时候就不要包含其默认值。即如下这个`street`字段如果为空
```go
data := {
    "street": "",
}
```
下面这种方式解析的结果，json中包含`street`字段。
```go
type address struct {
	Street  string `json:"street"`  // 街道
}
```
```json
{
	"street": "",
}
```
而如果填写了`omitempty`，空字段情况下`json`就不包含该字段。
```go
type address struct {
	Street  string `json:"street,omitempty"`  // 街道
}
```
#### 指针字段与omitempty
> Using a pointer field, and specify omitempty allows you to do that. If the field wasn't specified in the JSON data, then the field in your struct will be nil, if not: it'll point to an integer of value 0.

指针字段+`omitempty`的好处是，`json`解码后，如果`json`不包含该字段则指针字段为`nil`，否则`json`中字段存在且值为空，那么指针字段为`0`。

### 交叉编译
在`mac`平台编译`linux`的可执行程序 `CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build ./`
`CGO_ENABLED`：用来控制golang 编译期间是否支持调用 cgo 命令的开关，其值为1或0，默认情况下值为1，可以用 go env 查看默认值。交叉编译不支持 CGO 所以要禁用它
`GOOS`：目标平台的操作系统（darwin、freebsd、linux、windows）
`GOARCH`：目标平台的体系架构（386、amd64、arm）

### import 点、下划线、别名
点操作：`import( . “fmt” )` 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的`fmt.Println(“hello world”)`  可以省略的写成`Println(“hello world”)`
别名操作：`import( f “fmt” )`别名操作调用包函数时前缀变成了重命名的前缀，即`f.Println(“hello world”)`
下划线操作：忽略包

### time.Now().After()与time.After()
`time.Now().After()`是属于`time/time`，一般主动调用`after`来通过返回的`bool`了解是否在时刻`u`之后。
```go
// After reports whether the time instant t is after u.
func (t Time) After(u Time) bool {
	if t.wall&u.wall&hasMonotonic != 0 {
		return t.ext > u.ext
	}
	ts := t.sec()
	us := u.sec()
	return ts > us || ts == us && t.nsec() > u.nsec()
}
```
`time.After()`属于`time/sleep`。是对`NewTimer()`的封装，返回一个channel
```go
// After waits for the duration to elapse and then sends the current time
// on the returned channel.
// It is equivalent to NewTimer(d).C.
// The underlying Timer is not recovered by the garbage collector
// until the timer fires. If efficiency is a concern, use NewTimer
// instead and call Timer.Stop if the timer is no longer needed.
func After(d Duration) <-chan Time {
	return NewTimer(d).C
}
```
通常是定时后，配合`select`使用如下例子。`select`会执行表达式`time.After`，并试着读取，由于还没有到after，即阻塞。此时有其他`case`触发也可以执行。在计时器计时结束后，`case <-time.After(timeout):`会被触发。
```go
select{
    case <-time.After(timeout):
    case xx:
}
```