#### 文档
文档是MongoDB的核心概念，文档就是键值对的一个有序集。有如下注意几点：

- `\0`只能用于结尾
- `.$`有特殊意义
- 区分类型和大小写，`{"foo":3}`和`{"foo":"3"}`不同。
#### 集合
尽管MongoDB没有强制要求，但为了能够更快地查询，我们通常创建一个模式，把相关类型的文档组织在一起。
### 数据类型
#### 日期
在JavaScript中，`Date`类可以用作MongoDB的日期类型。创建日期对象时，应使用`new Date(...)`，而非`Date(...)`。
> 如将构造函数 (constructor)作为函数进行调用(即不包括new的方式)，返回的是日期的字符串表示，而非日期 (Date)对象。这个结果与MongoDB无关，是 JavaScript的工作机制决定的。如果不注意这一点，没有始终使用日期(Date)构造函数，将得到一堆混乱的日期对象和日期的字符串。 

#### 内嵌文档
文档可以作为键的值，这样的文档就是内嵌文档。使用内嵌文档，可以**使数据组织方式更加自然**，不用非得存成扁平结构的键/值对。
不足：MongoDB这样做的坏处就是会导致更多的数据重复。假设“address”是关系数据库中的一个独立的表，我们需要修正地址中的拼写错误。当我们对“people”和“address”执行连接操作时，使用这个地址的每个人的信息都会得到更新。但是在 MongoDB中，则需要对每个人的文档分别修正拼写错误。
#### _id和ObjectId
ObjectId是"_id"的默认类型。它设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。
> 这是 MongoDB采用`ObjectId`，而不是其他比较常规的做法(比如自动增加的主键)的主要原因，因为在多个服务器上同步自动增加主键值既费力又费时。因为设计MongoDB的初衷就是用作分布式数据库，所以能够在分片环境中生成唯一的标示符非常重要。 

ObjectId使用12字节的存储空间，是实际存储数据的两倍长。其生成方式如下：
![image.png](../static/img/%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%971.png)
时间戳：提供了秒级别的唯一性，这意味着`ObjectId`**大致**会按照插入的顺序排列。
PID：为了确保在同一台机器上并发的多个进程产生的ObjectId是唯一的，接下来的两字节来自产生ObjectId的进程的进程标识符(PID)。
计数器：确保相同进程同一秒产生的ObjectId也是不一样的。
### 创建、更新和删除文档
#### 批量插入
如果在执行批量插入的过程中有一个文档插入失败，那么在这个文档之前的所有文档都会成功插入到集合中，而这个文档以及之后的所有文档全部插入失败。
#### 更新
同时执行的两个更新操作，以最新的申请为准。
下面提供了使用更新，将文档部分字段进行替换的方法，主要通过创建js对象来更新内容。
```go
> var joe = db.users.findOne({"name" : "joe"}); 
> joe.relationships = {"friends" : joe.friends, "enemies" : joe.enemies};
{
    "friends" : 32,
"enemies" : 2
}> joe.username = joe.name; "joe"
> delete joe.friends;
true
> delete joe.enemies;
true
> delete joe.name;
true
> db.users.update({"name" : "joe"}, joe);
```
这里可能遇到由于字段不唯一，导致`findOne()`匹配错误的情况，如有多个`name:joe`的文档，一次最好使用唯一标识`_id`。
### 复制
#### 复制				 				
在MongoDB中，创建一个副本集之后就可以使 用复制功能了。副本集是一组服务器，其中有一个**主服务器**(primary)，用于处理客户端请求;还 有多个**备份服务器**(secondary)，用于保存主服 务器的数据副本。如果主服务器崩溃了，备份服务 器会自动将其中一个成员升级为新的主服务器。 
#### 建立副本集
下面可以建立一个包含3个节点的副本集
```go
> replicaSet = new ReplSetTest({"nodes" : 3})
> // 启动3个mongod进程
> replicaSet.startSet() >
> // 配置复制功能
> replicaSet.initiate()
```
`isMaster()`可以判断当前节点是否是主节点，并且如果不是主节点则会告知主节点是哪一个。
```go
> primaryDB.isMaster() {
"setName" : "testReplSet", "ismaster" : true, "secondary" : false, "hosts" : [
        "wooster:31000",
        "wooster:31002",
        "wooster:31001"
],
"primary" : "wooster:31000", "me" : "wooster:31000", "maxBsonObjectSize" : 16777216, "localTime" : ISODate("2012-09-
28T15:48:11.025Z"), "ok" : 1
```
主节点可以写入，`secondary`副节点只能读取。备份节点可能会落后于主节点，可能没有最新写入的数据，所以备份节点在默认情况下会拒绝读取请求，以防止应用程序意外拿到过期的数据。因此，如果在备份节点上做查询，可能会得到一个错误提示，说当前节点不是主节点。
```go
> secondaryDB.coll.find()
error: { "$err" : "not master and slaveok=false", "code" : 13435 }
```
这是为了保护应用程序，以免意外连接到备份节点，读取到过期数据。如果希望从备份节点读取数据，需要设置“从备份节点读取数据没有问题”标识，`setSlaveOk()`。注意**`slaveOk`是对连接设置的而不是数据库设置**的。
### 分片
#### 理解集群的组件
分片的目标之一是创建一个拥有5台、10台甚至 1000台机器的集群，整个集群对应用程序来说就像是一台单机服务器。为了对应用程序隐藏数据库架构的细节，在**分片之前要先执行mongos进行一次路由过程。这个路由服务器维护着一个“内容列表”，指明了每个分片包含什么数据内容。**应用程序只需要连接到路由服务器，就可以像使用单机服务器一样进行正常的请求了，如图13-1所示。路由 服务器知道哪些数据位于哪个分片，可以将请求转 发给相应的分片。
#### 主分片和副本集
主分片指的是组成分片的整个副本集。
副本集的主节点是副本集中能够处理写请求的单台服务器。
#### 配置服务器
配置服务器保存着集群和分片的元数据，`mongos`需从配置服务器获取配置信息，因此配置服务器应该先于任何`mongos`进程启动。
> 启动配置服务器时，**不要**使用--replSet选项：配置服务器不是副本集成员。mongos会向所有3台配置服务器发送写请求，执行一个两步提交类型 的操作，以确保3台服务器拥有相同的数据，所以这3台配置服务器都必须是可写的（在副本集中， 只有主节点可以处理客户端的写请求)。 

#### 将副本集转换为分片
下面可以将包含了`server-1\2\3\4\5`的副本集转换为分片。
```go
> sh.addShard("spock/server-1:27017,server- 2:27017,server-4:27017")
{
"added" : "spock/server-1:27017,server- 2:27017,server-4:27017",
"ok" : true }
```
转换为分片之后，就需要通过`mongos`访问，而不是直接访问副本集。
#### mongo分片的拆分块
mongos就会在配置服务器上更新这个块的元信息。块拆分只需改变块的元数据即可，而无需进行数据移动。 

