### 3.1 慢查询分析
redis会记录慢查询日志，慢查询只统计命令执行的时间，而不包含发送命令、命令排队时间。所以没有慢查询并不代表客户端没有超时时间。

### 3.3 Pipeline
可以用Pipeline模拟出批处理操作，但有区别：1.原生批量命令是原子的，Pipeline是非原子的。2.原生批量命令是一个命令对应多个key，Pipeline支持多个命令。
Pipeline组装的命令个数不能没有限制，否则会增加客户端的等待时间并且网络阻塞，这种情况可以拆分成多个Pipeline。

### 3.4 事务与Lua
Redis提供简单的事务功能，可以使一组命令顺序地原子执行，但不支持回滚。如果命令错误，则整个事务无法执行。运行时错误，则无法进行回滚，需要由开发人员修复。

### 3.5 Bitmaps
`bitop op destkey key[key....]` bitop是一个复合操作，它可以做多个Bitmaps的交集、并集、非、异或操作并将结果保存在destkey中。
比如用bitmaps存某一个对应userid是否访问网站，那么两天的交集就是两天都访问过网站的用户数量。如果想知道两天任意一天都访问过网站的用户数量，就可以使用并集。

### 3.6 HyperLogLog
适用于：1. 只为了计算独立总数（对key进行add\count\merge），不需要获取单条数据。2. 可以容忍一定误差率。

#### 10.7.3 Pub/Sub广播问题
集群模式下，内部实现对所有publish命令都会向所有的节点进行广播，这会造成带宽负担。
针对这种情况建议使用sentinel哨兵结构专门用于Pub/Sub功能，从而规避大量节点集群内使用。

### 11 缓存设计
#### 11.1 收益和成本
收益：1. 加速读写。缓存的全内存操作会比持久化了的存储层要快。2. 降低后端负载。可以减少后端访问量，如复杂的SQL。
成本：1. 数据不一致。存在一定的窗口期使得缓存层和存储层数据不一致。2. 代码维护成本。 需要同时处理缓存层和存储层逻辑。3. 运维成本：如Redis运维。
常用场景：1. 开销大的复杂计算。如Mysql的复杂查询。 2. 加速请求响应。

#### 11.1 缓存更新策略
缓存中的数据有生命周期，需要在指定时间后被删除或更新。
- LRU/LFU/FIFO算法剔除：当缓存超过阈值之后，根据算法对数据剔除。一致性差，不需要维护成本。
- 超时剔除：对缓存设置过期时间，使得数据自动删除。一段时间窗口内存在一致性问题，维护成本适中，指定expire即可。
- 主动更新：更新真实数据后，立即更新缓存，如双写。一致性好，维护成本高。
使用场景：低一致性业务建议配置最大内存和淘汰策略的方式使用。高一致性业务可以结合使用**超时剔除和主动更新**，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据。

#### 11.2 缓存粒度
选择缓存全部数据还是部分数据，需要根据通用性、空间占用比（内存空间+网络带宽）、代码维护性三点进行取舍。缓存全部数据虽然通用性好，但有占用内存空间大、网络IO数据多、序列化反序列化内容多等问题。

#### 11.4 穿透优化
缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中。这样每次都会对存储层发送请求，可能使得后端存储负载加大宕机。通过统计总调用数、缓存层命中数、存储层命中数，如果有大量存储层空命中，可能就是出现了缓存穿透问题。缓存穿透可能是自身业务代码或数据出现问题、或是恶意攻击。
- 缓存空对象：将空对象保存到缓存层。但可能造成缓存层存储更多键，需要更多的内存空间。并且有缓存层和存储层的数据不一致情况。建议对空对象设置较短的过期时间。
- 布隆过滤器：在访问缓存层之前，将存在的key存储在布隆过滤器中，做拦截。其适用于数据相对固定的场景。

#### 11.5 无底洞优化
无底洞现象是指，增加了大量节点性能反而下降的情况。这是因为水平扩容后，键值分得不到更多的节点上，分布式批量操作涉及多次网络时间导致的。可以从命令本身如SQL语句优化、减少网络通信次数、降低介入成本如使用长连接等角度优化。
减少网络通信次数方面，有以下几种方案：
- 串行命令：实现简单，但大量keys请求延迟高。
- 串行IO：将同一个Node上的多个key操作聚合成一个操作，大量nodes延迟严重。
- 并行IO：所有请求并行处理，延迟取决于最慢响应节点。难实现。
- hash_tag：将数据映射到同一个节点，但可能出现数据倾斜的问题。

#### 11.6 雪崩优化
雪崩是缓存层挂掉，大量请求发向后端。可以从下面几点解决：
- 保证缓存层服务的高可用性。构建集群。
- 依赖隔离组件为后端限流并降级。如推荐服务，如果个性化推荐服务不可用，可以降级补充热点数据。
- 提前演练，做一些预设方案。

#### 11.7 热点key重建优化
当一个key是一个热点key，并发量非常大。并且其重建不能在短时间完成，可能是一个复杂计算。这个key失效的瞬间，触发大量线程重建缓存，造成后端负载加大宕机。
- 互斥锁：通过加互斥锁，只允许一个线程重建缓存。可能会有死锁问题。
- 永不过期：不对key设置过期时间，但维护逻辑过期时间。有数据不一致问题以及逻辑过期时间增加代码维护成本。