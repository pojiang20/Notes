#### 60. 和为 K 的子数组
https://leetcode.cn/problems/subarray-sum-equals-k/
Q: 为什么不能用滑动窗口
A: 滑动窗口通常用于解决数组或列表中连续子序列的问题，例如求和、最大值/最小值或其他特定条件。它的关键思想是使用两个指针（左右边界）创建一个窗口，并基于特定条件移动这些指针。
但是，在这个问题中，如果k是负数，就不能简单地使用滑动窗口了。原因如下：
1. **非递增**：滑动窗口算法通常依赖于问题的单调性。在处理连续子数组的和等于某个值k的问题时，如果k为正，总可以通过不断移动右边界来使子数组的和趋近k。如果当前和超过k，我们可以移动左边界以减小和，反之，如果当前和小于k，我们可以移动右边界以增加和。因此，无论nums中的元素是正数还是负数，只要k为正，就可以保证子数组的和是递增的。然而，当k为负数时，我们不能保证添加更多的元素会让总和更接近k，因此滑动窗口并不能有效求解。

2. **无法有效缩小窗口**：当子数组的和超出目标时，滑动窗口算法会尝试通过移动左指针来缩小窗口。但如果k是负数，那么即使子数组的和超出目标，我们也不能简单地移动左指针来减小和，因为添加一个负数可能会使总和更接近k。

所以在这个问题中，如果k可能为负数，一个更通用的方法可能是使用前缀和+哈希表的方法进行求解。

## 二刷注意

#### 分割回文串
注意判定是否回文串的f[i][j]是如何构建的

#### 79单词搜索
判断结束的顺序
```
    if(g[sx][sy]!=word[u]) return false;
    if(u==word.size()-1) return true;
```

#### 739每日温度
注意如何构建单调栈

#### 153寻找旋转排序数组中的最小值
- [x] 增强记忆

#### 35搜索插入位置
增强记忆

#### 322. 零钱兑换
完全背包问题两种形式，物品可以选择无限个的背景下，指定容量所需要的最大价值或最小价值。

这道题有两种思考方式：
1. 对于任意一个数字i，其最小价值一定是min(dp[i-1*1],dp[i-2*2],dp[i-3*3]...)
2. 完全背包问题模板，i个物品，j从物品i的最小体积开始一直遍历到m。
```
class Solution {
public:
    int numSquares(int n) {
        // 无限件物品，构成容量n的最小价值
        vector<int> dp(n+1,1e8);
        dp[1]=1,dp[0]=0;
        // for(int i=2;i<=n;i++){
        //     for(int j=1;j*j<=i;j++){
        //         dp[i]=min(dp[i],dp[i-j*j]+1);
        //     }
        // }

        // 每件物品
        for(int i=1;i*i<=n;i++){
            // 物品的最小体积
            for(int j=i*i;j<=n;j++){
                dp[j]=min(dp[j],dp[j-i*i]+1);
            }
        }
        return dp[n];
    }
};
```

#### 45. 跳跃游戏 II
- [x]从第一个位置开始跳

#### 128. 最长连续序列
增强记忆

#### 42. 接雨水
梯形解法增强记忆

#### 230. 二叉搜索树中第K小的元素
中序遍历过程统计访问的第k个数字

#### 153寻找旋转排序数组中的最小值
- [ ] 增强记忆

#### 139. 单词拆分
判断子串的时候是s.substr(s,j-i); 即它会包含j而不包含i。

## 2024.1.25
#### 72. 编辑距离
旧状态到新状态有两种更新方式：
1. 新状态从插入、删除和修改三个操作的最小值得到，即f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1]+s1[i]==s2[j])
```
f[i][j]=min(f[i-1][j],f[i][j-1]);
if(s1[i]==s2[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
else f[i][j]=min(f[i][j],f[i-1][j-1]+1);
```
2. 新状态根据s1[i]和s2[j]划分为两种情况，s1[i]==s2[j]则变为f[i-1][j-1]子问题，否则是插入、删除和修改。
```
if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1];
else f[i][j]=min(f[i-1][j],f[i][j-1],f[i-1][j-1]+1);
```

#### 139. 单词拆分
关键是在n个字母的n+1个缝隙之间插入隔板，注意：
1. 隔板有n+1个
2. 两隔板之间单词长度为j-1

#### 347. 前 K 个高频元素
小顶堆
```
priority_queue<int,vector<int>,greater<>> heap;
```
默认大顶堆
```
priority_queue<int> heap;
```

#### 98. 验证二叉搜索树
中序遍历，访问的节点是已知序列中的最大值

#### 437. 路径总和 III
需要注意一下统计res和mp[t]++的顺序
如果先mp[t]++再res+,会有targetSum为0时，把mp[t]++的1种情况算进去，而这种情况不包含任何节点，是不符合情况的。
```
    void preOrder(TreeNode* p,long long parentsSum,int targetSum){
        if(p==nullptr) return ;
        // 加入前缀和
        long long t=parentsSum+p->val;
        // 判断前缀是否存在
        res+=mp[t-targetSum];
        mp[t]++;
        preOrder(p->left,t,targetSum),preOrder(p->right,t,targetSum);
        mp[t]--;
    }
```

#### 141. 环形链表
p2先走，判空，判相等，p1p2同时移动
```
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *p1=head,*p2=head;
        while(p2!=nullptr){
            p2=p2->next;
            if(p2==nullptr) break;
            if(p2==p1) return true;
            p2=p2->next,p1=p1->next;
        }
        return false;
    }
};
```