#### 05 命名类方法时的抽象思维
不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。
比如`getAliyunPictureUrl()`就不是一个具有抽象思维的命名，因为如果要把图片存储到其他地方，就需要需改命名。而`getPictureUrl()`则不论内部使用什么储存方式，都适用。
#### golang中的继承
参考[https://studygolang.com/articles/17257](https://studygolang.com/articles/17257)、[https://learnku.com/articles/32295](https://learnku.com/articles/32295)
#### 06 OOP的思考过程
OOP是以类为思考对象，在进行OOP的时候，**并不是思考如何将复杂的流程拆解为一个个方法，而是去思考如何给业务建模、如何将需求翻译为类、如何给类之间建立交互关系，**而完成这些工作完全不需要考虑复杂的处理流程。在有了类的设计之后，再像搭积木一样，按照处理流程，将类组装起来形成整个程序。
#### 07 看似OOP实则POP：滥用全局变量和全局方法
POP如C语言开发，全局变量和全局方法很多，而OOP的Java开发中，全局变量和全局方法并不多见。
以常量为例，常量是一种常见的全局变量，OOP中通常将其放到`Constants`类中，而切忌将所有常量都放到一个统一的`Constants`，应该将其拆分成如`MysqlConstants`、`RedisConstants`这样具体的情况。
只包含静态方法不包含任何属性的 Utils 类，是POP，但它能很好解决通用工具代码复用问题，所以使用时应该避免滥用，即是否需要单独定义`utils`类。
#### 09 基于接口编程vs实现类
在业务场景中，某个功能只有一种实现方式，未来也可能被其他实现方式替代，那么就没必要为其设计接口而直接使用实现类即可。
#### 10 组合与继承
`golang`完全摈弃了继承，语法上只有实现/接口之间的组合。
继承的思维方式：设计一个鸟的类`AbstractBird`，由于有的鸟会飞有的鸟不会飞以及复用代码（否则每一个具体类都需要重写），因此创建`AbstractFlyableBird`\`AbstractUnFlyAbleBird`，而由考虑鸟会不会叫，需要定义`AbstractFlyableTweetableBird`、`AbstractFlyableUnTweetableBird`、 `AbstractUnFlyableTweetableBird`、`AbstractUnFlyableUnTweetableBird`，这样的结果就是类指数性增加。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/1060671/1665915544359-901025fe-d463-45bc-b635-ae4a0592a4e9.png#clientId=ua41bac79-1ae8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=184&id=u57c8efa3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1070&originalType=binary&ratio=1&rotation=0&showTitle=false&size=169278&status=done&style=none&taskId=u0b47f94c-a14f-4827-bcc4-93214c5b8da&title=&width=535)
组合、接口、委托替代继承的思维方式：用接口表示某种特性如`Tweetable`、`EggLayable` 接口，为了使得代码复用又可以定义实现类如实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。这样的好处是没有复杂的继承关系，而是功能组合。
```java
public class Ostrich implements Tweetable, EggLayable {// 鸵鸟 private TweetAbility tweetAbility = new TweetAbility(); // 组合 private EggLayAbility eggLayAbility = new EggLayAbility(); // 组合 //... 省略其他属性和方法...
    @Override
    public void tweet() { 
        tweetAbility.tweet(); // 委托
    }
    @Override
    public void layEgg() { 
        eggLayAbility.layEgg(); // 委托
    }
}
```
